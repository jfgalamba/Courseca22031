NOTAS: 
    . email -> email_addr
    . auth_cookie -> session_cookie
    . Incorporar captchas 
    . Bloquear conta por excesso de tentativas falhadas

-----------------------------------------------------------
1a PARTE - A - Back to Basics
-----------------------------------------------------------

o acabar...

-----------------------------------------------------------
2a PARTE - B - Templates
-----------------------------------------------------------

o acabar...

-----------------------------------------------------------
3a PARTE - C - Views and Services
-----------------------------------------------------------

o 1. Adaptar HTML / Templates

    * Home: counters, popular courses, selected trainers

    * About: counters, testimonials

    * Register: name, email, password, check

    * Login: email, password

    * Courses: avalaible courses,

    * Course detail: name, trainer, price, avalaible seats, schedule, enroll
                     (syllabus fica por fazer p/ próxima versão)

    * assets
        . nova dir courses

    * _layout + assets: 
        - novas css/scripts
        - menu superior muda se estiver logado: entrar + registar -> sair + minha conta
        - testar directamente com True e False
    * Template com local para CSSs à medida
    * Colocar views a devolver dados dummy em dicionários

NOTAS p/ FORMAÇÃO
    - Começar por rever o HTML anterior e quais as alterações introduzidas
      (mencionando o que vamos implementar e que vamos deixar ficar para já)

o 2. Implementar ViewModels e Services (excepto register/login)

    - Introduzir padrões viewmodels e services

    - Criar módulo common com viewmodel

    - Implementar viewmodels e services para Home:

        - Criar pasta services e começar por implementar contadores 
            . users_service (students_service + instructors_service)
            . courses_service
            NOTA: viewmodels serão implementadas nas views (excepto base, 
            que está no common)

        - Para popular courses:
            . Implementar get_popular_courses
            . Criar DIR "models" para ter o modelo de dados (de futuro ligará ao 
              SQLAlchemy): Course, Student, Trainer, Testimonial.
        - Acrecentar is_logged_in ao template _layout.pt e testar
        - Acrescentar base_viewmodel às funções de account
    
-----------------------------------------------------------
4a PARTE - D - User and Forms
-----------------------------------------------------------

o Abordar padrão GET>POST>Redir para Register

o Abordar PFD geral do site

o Implementar GET>POST>Redir Register: 1a PARTE

    * Explicar que este template vai ser usado quando se acede pela 
        1a vez mas também quando ocorre um erro na criação da conta, e 
        queremos devolver os mesmos dados ao utilizador

    * Acrescentar input para campo birth_date com min = 1920-01-01 e 
        max = ${max_date}; acrescentar max_date ao viewmodel do register (em baixo)

    * Criar viewmodel com dados vazios do user (porque vai ser necessário)

    * Definir @router.post para o método register

    * desenvolver post_register_viewmodel

    * criar student_service.create_account

    * redirect com RedirectResponse primeiro só com url para verificarmos
      que ele faz POST por omissão mas nós queremos GET; temos que dar 
      HTTP status code correcto -> 302

o Interrupção: refactoring do código

    * falar de funções auxiliares em common

    * Definir nova classe ViewModel que herda de dict (nesta fase com 
      is_logged_in fixo)

    o Adicionar classe ViewModel a restantes views e remover métodos antigos


o Implementar GET>POST>Redir Register: 2a PARTE

    * criar serviço de autenticação para fazer autenticação com cookies

    * incluir hashing da cookie juntamente com user_id para verificação da
      integridade

    * utilizar função de auth_service para definir estado de is_logged_in
      no base_viewmodel; problema: como aceder ao request?

        . definir global_request como ContextVar
        . criar middleware (add_global_request_middleware) 
        . definir configure_middleware 
    
    * nesta altura criar folder infrastructure e dividir conteúdo em 
      common.py, viewmodel.py, 
    
    * refactoring

o Implementar logout (POST /account/logout)

    * apagar cookie (na response) e redirect para home

o Implementar login (GET /account/login)

o Implementar login (POST /account/login)

o Criar view para account (para GET /account) (UPDATE dos dados da conta)

    * definir template para index a partir de register

    * Se não tiver sido criada para o register, criar classe Student 
      (com birth_date e outras coisas)

    * Desenvolver get_current_user para obter utilizador actual na fake DB 
      a partir do request e mencionar motivação => utilizador actual pode 
      estar inactivo, logo não podemos assumir que user_id/student_id na 
      cookie está válido

    * Criar viewmodel para GET /account a devolver os dados do 
      current user

o Criar view para POST /account

    * ACABAR...

-----------------------------------------------------------
5a PARTE - E - Access Control
-----------------------------------------------------------

o Problemas: 

    1 - Utilizador autenticado pode aceder a /account/login e 
        /account/register, utilizador anónimo pode aceder /account/logout
        e a /account

    2 - Precisamos de um get_user da BD pq user_id tirado da cookie pode 
        não estar válido (por exemplo, conta pode ter sido inactivada na 
        BD por um admin) => por esta altura isto pode já estar resolvido
        se get_current_user já tiver sido implementado no passo anterior

o O que pretedemos obter:

    * Acesso autenticado a /account/{register,login} => redireccionar para /

    * Acesso não-autenticado a /account => redireccionar para página 404
      (apesar do código correcto em teoria ser o 401). Porquê? Para não 
      dar informações a um atacante

    - Ver PFD

o Ligeiro refactoring: 

    * exec_login, usada em post_register e post_login

    * auth.get_current_user / student_service.get_user_by_id [Nota: isto 
     já poderá estar implementado por esta altura]

o Como é que deve funcionar o controlo de fluxo e falar de dependências

o Criar em auth.py

    * requires_auth():

    * requires_unauth():

    * HTTPUnauthorizedAccess(HTTPException):

    * HTTPRequiresUnauthenticated(HTTPUnauthorizedAccess):

    * Alterar ViewModel: utilizar get_current_user em vez de get_auth_from_cookie
      (assim os botões da home ficam consistentes com a existência de utilizador 
       válido na BD)

o Instalar dependências requires_auth, requires_unauth nos locais apropriados 
  (de account) e testar.

    - Confirmar com mensagens no browser

o Desenvolver páginas de redirecção para excepções em cima

    - Fazer template 404.pt para not found

    - Instalar exception_handler em main.py
        . criar config_exception_handlers
        . criar constantes com caminhos para os templates

NOTA: A partir daqui o Guião já não precisa de ser tão promenorizado

-----------------------------------------------------------
6a PARTE - F - Base de Dados
-----------------------------------------------------------

o Alterações:

    * Cursos passam a ser individuais e adquiridos

    * Inscrever passa a Comprar

    * Desaparece avalaible_seats, schedule

o Definir modelo de dados

o Adicionar sqlalchemy==1.4.* a requirements.txt

o Script de inicialização da BD (não esquecer acrescentar palavras passe-hashadas
  mais sal)

o Adaptação das views e dos templates (excepto do /account pq esse vai 
  precisar de muitas adaptações pq há muitos dados novos)

o Redefinição da configuração do sistema baseado no Flask:
    * main.py -> run_server.py, config_server.py, config_settings.py
      NOTA: redefinir passos em cima para logo de início existir pelo menos 
            run_server.py + config_server.py

-----------------------------------------------------------
7a PARTE - G - PRÓXIMOS DESENVOLVIMENTOS
-----------------------------------------------------------

o Providers externos para autenticação

o Assincronizar a BD e passar p/ MySQL

o Adicionar HTTPS

o Confirmação de endereço de email

o Recuperação da password


--------------------------------

o Incorporar captchas 

o Bloquear conta por excesso de tentativas falhadas


NOTA: Considerar hipótese de criar repositório apenas para este exemplo.
A partir daqui, queremos fazer este projecto até ao fim e deixa de haver 
A, B, etc. (até porque isto aumenta brutalmente a dimensão do .git e de 
todo o repositório). No entanto, posso continuar a dividir em A, B, C a 
minha versão (que não vai para Git), isto para efeitos de demonstração 
em aula.

o Implementar profile_image_url 

    * fazer upload de uma imagem
