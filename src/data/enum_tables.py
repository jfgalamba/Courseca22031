# WARNING: THIS FILE WAS GENERATED AUTOMATICALLY. ALL CHANGES MADE TO THIS
# FILE WILL BE LOST WHEN A NEW VERSION IS GENERATED AGAIN.

import enum

from sqlalchemy import (
    Column,
    ForeignKey,
    Integer,
    String,
)
from sqlalchemy.orm import (
    relationship,
    declarative_mixin,
    declared_attr,
    Session,
)

from data.model_base import SqlAlchemyBase


__all__ = (
    'EmailAddrStatus',
    'EmailAddrStatusEnum',
    'EmailAddrStatusMixin',
    'HashAlgo',
    'HashAlgoEnum',
    'HashAlgoMixin',
    'SocialNetworkType',
    'SocialNetworkEnum',
    'SocialNetworkAddrMixin',
    'UserAccountStatus',
    'UserAccountStatusEnum',
    'UserAccountStatusMixin',
    'CourseStatus',
    'CourseStatusEnum',
    'CourseStatusMixin',
    'populate_enum_tables',
)


class EmailAddrStatusEnum(enum.Enum):
    Unconfirmed = (1, "Email address is yet to be validated")
    Confirmed = (2, "Email address was confirmed through an established process of email validation")

    @property
    def id(self) -> int:
        return self.value[0]

    @property
    def description(self) -> str:
        return self.value[1]

class EmailAddrStatus(SqlAlchemyBase):
    __tablename__ = 'EmailAddrStatus'

    id = Column(Integer, primary_key = True)
    name = Column(String(20), unique = True, nullable = False)
    description = Column(String(100), nullable = False)

    user_login_data_collection = relationship('UserLoginData', back_populates='_email_addr_status')

@declarative_mixin
class EmailAddrStatusMixin:
    @declared_attr
    def email_addr_status_id(cls):
        return Column(
            Integer, 
            ForeignKey('EmailAddrStatus.id'),
            nullable = False,
            server_default = f'{ EmailAddrStatusEnum.Unconfirmed.id }'
        )

    @property
    def email_addr_status(self) -> EmailAddrStatusEnum:
        return EmailAddrStatusEnum[self._email_addr_status.name]

    @email_addr_status.setter
    def email_addr_status(self, new_email_addr_status: EmailAddrStatusEnum):
        self.email_addr_status_id = new_email_addr_status.id    # type: ignore

    @declared_attr
    def _email_addr_status(cls):
        return relationship('EmailAddrStatus', back_populates = 'user_login_data_collection', lazy = 'immediate')

class HashAlgoEnum(enum.Enum):
    ARGON2 = (1, "Argon2 is a state of the art memory-hard password hash, and the winner of the 2013 Password Hashing Competition. Is intended to replace pbkdf2_sha256, bcrypt, and scrypt.")
    PBKDF2_SHA256 = (2, "Pure Python implementation of the PBKDF2-HMAC-SHA256 Password Storage Scheme provides a mechanism for encoding user passwords using the PBKDF2-HMAC-SHA256 message digest algorithm")
    PBKDF2_SHA512 = (3, "Pure Python implementation of the PBKDF2-HMAC-SHA512 Password Storage Scheme provides a mechanism for encoding user passwords using the PBKDF2-HMAC-SHA256 message digest algorithm")

    @property
    def id(self) -> int:
        return self.value[0]

    @property
    def description(self) -> str:
        return self.value[1]

class HashAlgo(SqlAlchemyBase):
    __tablename__ = 'HashAlgo'

    id = Column(Integer, primary_key = True)
    name = Column(String(20), unique = True, nullable = False)
    description = Column(String(100), nullable = False)

    user_login_data_collection = relationship('UserLoginData', back_populates='_hash_algo')

@declarative_mixin
class HashAlgoMixin:
    @declared_attr
    def hash_algo_id(cls):
        return Column(
            Integer, 
            ForeignKey('HashAlgo.id'),
            nullable = False,
            server_default = f'{ HashAlgoEnum.ARGON2.id }'
        )

    @property
    def hash_algo(self) -> HashAlgoEnum:
        return HashAlgoEnum[self._hash_algo.name]

    @hash_algo.setter
    def hash_algo(self, new_hash_algo: HashAlgoEnum):
        self.hash_algo_id = new_hash_algo.id    # type: ignore

    @declared_attr
    def _hash_algo(cls):
        return relationship('HashAlgo', back_populates = 'user_login_data_collection', lazy = 'immediate')

class SocialNetworkEnum(enum.Enum):
    twitter = (1, "Twitter address")
    facebook = (2, "Facebook address")
    instagram = (3, "Instagram address")
    linkedin = (4, "LinkedIn address")

    @property
    def id(self) -> int:
        return self.value[0]

    @property
    def description(self) -> str:
        return self.value[1]

class SocialNetworkType(SqlAlchemyBase):
    __tablename__ = 'SocialNetworkType'

    id = Column(Integer, primary_key = True)
    name = Column(String(20), unique = True, nullable = False)
    description = Column(String(100), nullable = False)

    social_network_addr_collection = relationship('SocialNetworkAddr', back_populates='_social_network_type')

@declarative_mixin
class SocialNetworkAddrMixin:
    @declared_attr
    def social_network_type_id(cls):
        return Column(
            Integer, 
            ForeignKey('SocialNetworkType.id'),
            nullable = False,
            server_default = f'{ SocialNetworkEnum.twitter.id }'
        )

    @property
    def social_network_type(self) -> SocialNetworkEnum:
        return SocialNetworkEnum[self._social_network_type.name]

    @social_network_type.setter
    def social_network_type(self, new_social_network_type: SocialNetworkEnum):
        self.social_network_type_id = new_social_network_type.id    # type: ignore

    @declared_attr
    def _social_network_type(cls):
        return relationship('SocialNetworkType', back_populates = 'social_network_addr_collection', lazy = 'immediate')

class UserAccountStatusEnum(enum.Enum):
    Active = (1, "User account is active")
    Blocked = (2, "User account was blocked due to security concerns")
    Inactive = (3, "User account was inactivated. User will have to change password")

    @property
    def id(self) -> int:
        return self.value[0]

    @property
    def description(self) -> str:
        return self.value[1]

class UserAccountStatus(SqlAlchemyBase):
    __tablename__ = 'UserAccountStatus'

    id = Column(Integer, primary_key = True)
    name = Column(String(20), unique = True, nullable = False)
    description = Column(String(100), nullable = False)

    user_account_collection = relationship('UserAccount', back_populates='_status')

@declarative_mixin
class UserAccountStatusMixin:
    @declared_attr
    def status_id(cls):
        return Column(
            Integer, 
            ForeignKey('UserAccountStatus.id'),
            nullable = False,
            server_default = f'{ UserAccountStatusEnum.Active.id }'
        )

    @property
    def status(self) -> UserAccountStatusEnum:
        return UserAccountStatusEnum[self._status.name]

    @status.setter
    def status(self, new_status: UserAccountStatusEnum):
        self.status_id = new_status.id    # type: ignore

    @declared_attr
    def _status(cls):
        return relationship('UserAccountStatus', back_populates = 'user_account_collection', lazy = 'immediate')

class CourseStatusEnum(enum.Enum):
    Active = (1, "Course is open for enrollments")
    Inactive = (2, "Course is inactive for any given reason")
    Retired = (3, "Course has been retired because it's no longer relevant")

    @property
    def id(self) -> int:
        return self.value[0]

    @property
    def description(self) -> str:
        return self.value[1]

class CourseStatus(SqlAlchemyBase):
    __tablename__ = 'CourseStatus'

    id = Column(Integer, primary_key = True)
    name = Column(String(20), unique = True, nullable = False)
    description = Column(String(100), nullable = False)

    course_collection = relationship('Course', back_populates='_status')

@declarative_mixin
class CourseStatusMixin:
    @declared_attr
    def status_id(cls):
        return Column(
            Integer, 
            ForeignKey('CourseStatus.id'),
            nullable = False,
            server_default = f'{ CourseStatusEnum.Active.id }'
        )

    @property
    def status(self) -> CourseStatusEnum:
        return CourseStatusEnum[self._status.name]

    @status.setter
    def status(self, new_status: CourseStatusEnum):
        self.status_id = new_status.id    # type: ignore

    @declared_attr
    def _status(cls):
        return relationship('CourseStatus', back_populates = 'course_collection', lazy = 'immediate')

def populate_enum_tables(db_session: Session):
    enums_and_tables = (
        (EmailAddrStatusEnum, EmailAddrStatus),
        (HashAlgoEnum, HashAlgo),
        (SocialNetworkEnum, SocialNetworkType),
        (UserAccountStatusEnum, UserAccountStatus),
        (CourseStatusEnum, CourseStatus),
    )
    for enum_type, table in enums_and_tables:
        for enum in enum_type:
            row = table(id = enum.id, name = enum.name, description = enum.description) # type: ignore
            db_session.add(row)
    db_session.commit()
